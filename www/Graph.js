 /*****************************************
Copyright 2012 Brian M. O'Keefe (http://www.brianmokeefe.com)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  * *******************************************
  */

var Graph = {};
Graph.UI = {};

/**
 * Manages the Graph UI environment
 * @param containerId ID of the DOM container
 * @param width Width in pixels of the DOM container
 * @param height Height in pixels of the DOM container
 * @returns {Graph.Manager}
 */
Graph.Manager = function(containerId, width, height) {
	this.container = document.getElementById(containerId);
	this.height = height;
	this.width = width;
	this.nodes = [];
	this.edges = [];
	this.edgez = [];
	this.eventListeners = {};
	
	// Set the HTML5 Canvas object
	this.canvas = document.createElement('canvas');
	this.canvas.height = height;
	this.canvas.width = width;
	this.canvas.style.position = 'relative';
	this.context = this.canvas.getContext('2d');

	// Add the canvas to the container element
	this.container.appendChild(this.canvas);
	this.whoAmI = "Graph.Manager";
};

Graph.Manager.prototype.addNode = function(fillcolor, position, radius) {
	node = new Graph.Node(this, fillcolor, position, radius);
	this.nodes.push(node);
	this.edgez.push(new Array());
	return node;
};

/**
 * Adds an edge between 2 nodes in the graph
 * @param parentNode Parent node
 * @param childNode Child node
 * @returns {Graph.Edge}
 */
Graph.Manager.prototype.addEdge = function(parentNode, childNode) {
	var edge = new Graph.Edge(parentNode, childNode);
	if (parentNode==childNode){
		return edge;
	}
	this.edges.push(edge);
	var pn=0;
	var cn=0;
	for(var i=0; i<this.nodes.length; i++) {
		if(this.nodes[i]==parentNode){
		pn=i;
		}
		if(this.nodes[i]==childNode){
		cn=i;
		}
	}
	this.edgez[pn].push(cn);
	this.edgez[cn].push[pn];

	//coloring start
	var len=this.nodes.length;
	var colornum=1;
	var colors=[1];
	var pool=[0];
	for(var i=1; i<=len; i++) {
		colors[i]=0;
		pool[i]=0;
	}
	var flag=0;
	for(; colornum<=len; colornum++){
		flag=0;

/**
		for(int i=1; i>0; ){
			if(i==len){

				for (int j=1; j<=colornum; j++){
					//var color='#'+(0x1000000+(Math.random())*0xffffff).toString(16).substr(1,6);
					for (int k=0; k<len;k++){
						if(colors[k]==j){
						//this.nodes[k].fillColor=color;
						}
					}
				}

				colors=function(){};
				pool=function(){};
				return edge;
			}
			flag=1;
			for(var j=0; j<len; i++){
				pool[j]=0;
			}
			for(int j=0; j<this.edgez[i].length&&this.edgez[i][j]<i; j++){
				pool[this.edgez[i][j]]=1;
			}
			for(int j=coloring[i]+1; j<=colornum; j++){
				if(pool[j]==0){
					coloring[i]=j;
					i++;
					flag=0;
					break;
				}
			}
			if(flag==1){
				coloring[i]=0;
				i--;
			}
		}
*/

		for(var i=0; i<len; i++) {
			colors[i]=0;
		}
	}


	//coloring end

	return edge;
};

/**
 * Redraws the screen
 */
Graph.Manager.prototype.paint = function() {
	this.context.clearRect(0,0,this.width,this.height);

	for(var i=0; i<this.nodes.length; i++) {
		var node = this.nodes[i];
		node.draw(this.context);
	}
	
	for(var i=0; i<this.edges.length; i++) {
		var edge = this.edges[i];
		edge.draw(this.context);
	}
};

/**
 * Paints the screen, calling the callback function immediately afterwards
 * @param paintCallback Callback function
 */		
Graph.Manager.prototype.paintWithCallback = function(paintCallback) {
	this.paint();
	paintCallback(this.context);
};

/**
 * Clears the UI
 */
Graph.Manager.prototype.clear = function() {
	this.context.clearRect(0,0,this.width,this.height);
};

/**
 * Registers the graph Manager to listen to the underlying context events
 */
Graph.Manager.prototype.registerListeners = function() {
	var manager = this;
	
	this.container.addEventListener('mousedown', function(evt) {
		manager.eventHandler(evt);
	}, false);
	
	this.container.addEventListener('mouseup', function(evt) {
		manager.eventHandler(evt);
	}, false);
	
	this.container.addEventListener('mousemove', function(evt) {
		manager.eventHandler(evt);
	}, false);
	
	this.container.addEventListener('mouseover', function(evt) {
		manager.eventHandler(evt);
	}, false);
};

/**
 * Handles the events generated by the underlying HTML5 context
 * @param evt The event object sent by the DOM
 */
Graph.Manager.prototype.eventHandler = function(browserEvent) {
	if (!browserEvent) {
		browserEvent = window.event;
	}
	
	var evt = new Graph.BrowserEvent(browserEvent);
	
	// Check each node in the hit area to see if it has any listeners for the event that was triggered
	for(var i=0; i<this.nodes.length; i++) {
		var node = this.nodes[i];
		if (node.isPointInPath(evt.offsetX, evt.offsetY)) {
			if (evt.type == 'mousedown' && node.eventListeners.mousedown !== undefined) {
				var listeners = node.eventListeners.mousedown.getListeners();
				for(var i = 0; i < listeners.length; i++) {
					listeners[i](evt, node);
				}
			}
			if (evt.type == 'mousemove' && node.eventListeners['mousemove'] !== undefined) {
				var listeners = node.eventListeners.mousemove.getListeners();
				for(var i = 0; i < listeners.length; i++) {
					listeners[i](evt, node);
				}
			}
			if (evt.type == 'mouseup' && node.eventListeners['mouseup'] !== undefined) {
				var listeners = node.eventListeners.mouseup.getListeners();
				for(var i = 0; i < listeners.length; i++) {
					listeners[i](evt, node);
				}				
			}
			if (evt.type == 'mouseover' && node.eventListeners['mouseover'] !== undefined) {
				var listeners = node.eventListeners.mouseover.getListeners();
				for(var i = 0; i < listeners.length; i++) {
					listeners[i](evt, node);
				}								
			}
		}
	}
	
	// Now check the Manager event handlers to fire any that are registered
	if (evt.type == 'mousedown') {
		if (this.eventListeners.mousedown !== undefined) {
			var listeners = this.eventListeners.mousedown.getListeners();
			for(var i = 0; i < listeners.length; i++) {
				listeners[i](evt, this);
			}
		}
	}
	if (evt.type == 'mouseup') {
		if (this.eventListeners.mouseup !== undefined) {
			var listeners = this.eventListeners.mouseup.getListeners();
			for(var i = 0; i < listeners.length; i++) {
				listeners[i](evt, this);
			}
		}
	}
	if (evt.type == 'mousemove') {
		if (this.eventListeners.mousemove !== undefined) {
			var listeners = this.eventListeners.mousemove.getListeners();
			for(var i = 0; i < listeners.length; i++) {
				listeners[i](evt, this);
			}
		}
	}
	if (evt.type == 'mouseover') {
		if (this.eventListeners.mouseover !== undefined) {
			var listeners = this.eventListeners.mouseover.getListeners();
			for(var i = 0; i < listeners.length; i++) {
				listeners[i](evt, this);
			}
		}
	}

};

/**
 * Add an event listener to the manager
 * @param evtName The event that the listener listens for
 * @param callback The listener function
 */
Graph.Manager.prototype.addEventListener = function(evtName, callback) {
	if (this.eventListeners[evtName] === undefined) {
		this.eventListeners[evtName] = new Graph.EventListenerCollection();
	}
	this.eventListeners[evtName].add(callback);	
};

/**
 * Clears all event listeners for the given event
 * @param evtName The event to clear the listeners for
 */
Graph.Manager.prototype.clearEventListeners = function(evtName) {
	if (this.eventListeners[evtName] !== undefined) {
		this.eventListeners[evtName].clear();
	}
};

/**
 * Determines objects in the area affected by the event
 * @param evt The DOM event object
 * @returns Array of Graph.UI.HitPoints in the area of the event
 */
Graph.Manager.prototype.hitTest = function(evt) {
	var hits = [];
	
	for(var i=0; i<this.nodes.length; i++) {
		var node = this.nodes[i];
		if (node.isPointInPath(evt.offsetX, evt.offsetY)) {
			var hitPoint = 
				new Graph.UI.HitPoint(
					node, 
					new Graph.Coordinates(
							evt.offsetX - node.position.x,
							evt.offsetY - node.position.y
					)
				);
			hits.push(hitPoint);
		}
	}
	return (hits.length > 0) ? hits : null;
};

/**
 * A node in the graph
 * @param manager The graph manager
 * @param fillcolor The color of the node
 * @param position The {Graph.Coordinates} position of the node
 * @param radius The radius of the node
 * @returns {Graph.Node}
 */
Graph.Node = function(manager, fillcolor, position, radius) {
	this.manager = manager;
	this.fillColor = fillcolor;
	this.position = position;
	this.radius = radius;
	this.eventListeners = {};
	this.whoAmI = "Graph.Node";
};

/**
 * Draws the graph node
 * @param context The HTML5 canvas to draw to.
 * @param offset The offset from the parent context to draw at.
 */
Graph.Node.prototype.draw = function(context, offset) {

	context.save();
	
	// Draw node
	context.strokeStyle = 'rgb(0,0,0)';
	context.fillStyle = this.fillColor;
	context.beginPath();
	context.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI, false);
	context.closePath();
	context.stroke();
	context.fill();
		
	context.restore();
};

/**
 * Adds an event listener to the node
 * @param evtName The event to listen to
 * @param callback The function to call when the event triggers
 */
Graph.Node.prototype.addEventListener = function(evtName, callback) {
	if (this.eventListeners[evtName] === undefined) {
		this.eventListeners[evtName] = new Graph.EventListenerCollection();
	}
	this.eventListeners[evtName].add(callback);	
};

/**
 * Clears all the event listeners for the given event
 * @param evtName The name of the event to clear listeners for
 */
Graph.Node.prototype.clearEventListeners = function(evtName) {
	if (this.eventListeners[evtName] !== undefined) {
		this.eventListeners[evtName].clear();
	}
};

/**
 * Erases the image of the node from the context
 * @param context The context to erase the image from
 */
Graph.Node.prototype.clear = function(context) {
	context.clearRect(this.position.x,this.position.y,this.width,this.height);
};

// Position functions
/**
 * Set the position in the context of the node
 * @param x X-axis position in pixels
 * @param y Y-axis position in pixels
 */
Graph.Node.prototype.setPosition = function(x, y) {
	this.position.x = x;
	this.position.y = y;
};

/**
 * Gets the position of the node
 * @returns {Graph.Coordinates} representing the center of the node
 */
Graph.Node.prototype.getPosition = function() {
	return this.position;
};

/**
 * Convenience function to get the right side of the node
 * @returns {Graph.Coordinates}
 */
Graph.Node.prototype.getRight = function() {
	return new Graph.Coordinates((this.position.x + this.radius), this.position.y);
};

/**
 * Convenience function to get the left side of the node
 * @returns {Graph.Coordinates}
 */
Graph.Node.prototype.getLeft = function() {
	return new Graph.Coordinates((this.position.x - this.radius), this.position.y);
};

/**
 * Convenience function to get the top of the node
 * @returns {Graph.Coordinates}
 */
Graph.Node.prototype.getTop = function() {
	return new Graph.Coordinates(this.position.x, (this.position.y + this.radius));
};

/**
 * Convenience function to get the bottom of the node
 * @returns {Graph.Coordinates}
 */
Graph.Node.prototype.getBottom = function() {
	return new Graph.Coordinates(this.position.x, (this.position.y - this.radius));
};

/**
 * Determines whether the node overlaps a given point
 * @param x X-axis location to test (in pixels)
 * @param y Y-axis location to test (in pixels)
 * @returns {Boolean}
 */
Graph.Node.prototype.isPointInPath = function(x,y) {
	// Where C() = Center point of circle, it is in the circle if (x - C(x)) squared + (y - C(y)) squared is less than radius squared.
	return ( Math.pow( (x - this.position.x), 2) + Math.pow( (y - this.position.y), 2) ) < Math.pow(this.radius, 2);
};

/**
 * A graph edge connecting two nodes
 * @param parentNode The parent of the relation
 * @param childNode The child of the relation
 * @returns {Graph.Edge}
 */
Graph.Edge = function(parentNode, childNode) {
	this.parentNode = parentNode;
	this.childNode = childNode;
	this.whoAmI = "Graph.Edge";
};

/**
 * Draws the line representing the edge to the context
 * @param context The context to draw the edge on.
 */
Graph.Edge.prototype.draw = function(context) {
	context.save();
	
	var deltaX = this.parentNode.getPosition().x - this.childNode.getPosition().x;
	var deltaY = this.parentNode.getPosition().y - this.childNode.getPosition().y;
	var coordStart, coordStop;
	
	if (Math.abs(deltaX) >= Math.abs(deltaY)) {
		coordStart = (deltaX < 0) ? this.parentNode.getRight() : this.parentNode.getLeft();
		coordStop = (deltaX < 0) ? this.childNode.getLeft() : this.childNode.getRight();
	} else {
		coordStart = (deltaY < 0) ? this.parentNode.getTop() : this.parentNode.getBottom();
		coordStop = (deltaY < 0) ? this.childNode.getBottom() : this.childNode.getTop();		
	}
	
	// Draw line and arrow from parent to child
	context.strokeStyle = 'rgb(0,0,0)';
	context.fillStyle = 'rgb(0,0,0)';
	
	// Draw the line and arrow cap
	context.beginPath();
	context.moveTo(coordStart.x,coordStart.y);
	context.lineTo(coordStop.x,coordStop.y);
	context.closePath();
	context.stroke();
	context.fill();
	
	context.restore();
};

/**
 * Represents a node and offset pair for a given point and its offset in the node
 * @param node The node that was hit
 * @param offset The offset from the top left of the node where the hit occurred
 * @returns {Graph.UI.HitPoint}
 */
Graph.UI.HitPoint = function(node, offset) {
	this.node = node;
	this.offset = offset;
	this.whoAmI = "Graph.UI.HitPoint";
};

/**
 * The offset of the hit
 * @returns {Graph.Coordinates}
 */
Graph.UI.HitPoint.prototype.getOffset = function() {
	return this.offset;
};

/**
 * The node that was hit
 * @returns {Graph.Node}
 */
Graph.UI.HitPoint.prototype.getNode = function() {
	return this.node;
};

/**
 * A X,Y point in the graph
 * @param x X-axis location in pixels
 * @param y Y-axis location in pixels
 * @returns {Graph.Coordinates}
 */
Graph.Coordinates = function(x, y) {
	this.x = x;
	this.y = y;
	this.whoAmI = "Graph.Coordinates";
};

/**
 * Collection of event listeners
 * @returns {Graph.EventListenerCollection}
 */
Graph.EventListenerCollection = function() {
	this.events = [];
	this.whoAmI = "Graph.EventListenerCollection";
};

/**
 * Adds an event to the event listener collection
 * @param callback The event listener function
 */
Graph.EventListenerCollection.prototype.add = function(callback) {
	this.events.push(callback);
};

/**
 * Removes all event listeners from the collection
 */
Graph.EventListenerCollection.prototype.clear = function() {
	this.events = [];
};

/**
 * Returns whether the collection contains any event listeners
 * @returns {Boolean}
 */
Graph.EventListenerCollection.prototype.hasListeners = function() {
	return this.events.length > 0;
};

/**
 * Returns the array of event listeners
 * @returns {Array}
 */
Graph.EventListenerCollection.prototype.getListeners = function() {
	return this.events;
};

/**
 * Event wrapper to standardize across IE/Mozilla/Chrome Javascript implementations
 * @param evt
 * @returns {Graph.BrowserEvent}
 */
Graph.BrowserEvent = function(evt) {
	this.offsetX = evt.offsetX ? evt.offsetX : (evt.clientX - evt.currentTarget.offsetLeft);
	this.offsetY = evt.offsetY ? evt.offsetY : (evt.clientY - evt.currentTarget.offsetTop);
	this.type = evt.type;
	this.whoAmI = "Graph.BrowserEvent";
};
